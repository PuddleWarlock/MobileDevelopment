### **1. Выполнение заданий**

#### **1.1. Создание ViewModel**
Для отделения логики отображения от `Activity`/`Fragment` и сохранения данных при повороте экрана были созданы классы ViewModel.
В качестве основного примера реализована `RecognitionViewModel`, которая управляет процессом распознавания птиц и хранит состояние экрана (загрузка, результат, ошибка).

**Фрагмент кода (`RecognitionViewModel.java`):**
```java
public class RecognitionViewModel extends ViewModel {

    // UseCases для взаимодействия с Domain слоем
    private final RecognizeBirdUseCase recognizeBirdUseCase;
    private final GetBirdInfoUseCase getBirdInfoUseCase;
    // ... другие UseCases

    // LiveData для хранения состояния UI
    private final MutableLiveData<String> recognitionResult = new MutableLiveData<>();
    private final MutableLiveData<BirdInfo> birdInfo = new MutableLiveData<>();
    private final MutableLiveData<Boolean> isLoading = new MutableLiveData<>();

    public RecognitionViewModel(RecognizeBirdUseCase recognizeBirdUseCase, ...) {
        this.recognizeBirdUseCase = recognizeBirdUseCase;
        // ... инициализация
    }

    // Геттеры для LiveData, чтобы View могла подписаться (возвращаем неизменяемую LiveData)
    public LiveData<BirdInfo> getBirdInfo() { return birdInfo; }
    public LiveData<Boolean> getIsLoading() { return isLoading; }

    // Метод логики
    public void startRecognition(byte[] imageBytes) {
        isLoading.setValue(true); // Обновление состояния
        recognizeBirdUseCase.execute(imageBytes, new RepositoryCallback<String>() {
            @Override
            public void onSuccess(String birdName) {
                fetchBirdInfo(birdName); // Цепочка вызовов
            }
            @Override
            public void onFailure(Exception e) {
                isLoading.setValue(false);
                // Обработка ошибки
            }
        });
    }
}
```

#### **1.2. Реализация ViewModelFactory**
Так как наши ViewModel требуют зависимостей (UseCases, которые в свою очередь требуют Repository), была реализована фабрика `ViewModelFactory`. Это позволяет внедрять зависимости при создании ViewModel.

**Фрагмент кода (`ViewModelFactory.java`):**
```java
public class ViewModelFactory implements ViewModelProvider.Factory {

    private final OrnithologyRepository ornithologyRepository;
    private final AuthRepository authRepository;

    public ViewModelFactory(Context context) {
        // Инициализация репозиториев (Data Layer)
        AppDatabase db = AppDatabase.getDatabase(context.getApplicationContext());
        this.ornithologyRepository = new OrnithologyRepositoryImpl(db.observationDao());
        UserPrefsStorage userPrefs = new UserPrefsStorage(context);
        this.authRepository = new AuthRepositoryImpl(userPrefs);
    }

    @NonNull
    @Override
    public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
        if (modelClass.isAssignableFrom(RecognitionViewModel.class)) {
            // Внедрение UseCases (Domain Layer) во ViewModel
            return (T) new RecognitionViewModel(
                    new RecognizeBirdUseCase(ornithologyRepository),
                    new GetBirdInfoUseCase(ornithologyRepository),
                    // ... другие зависимости
            );
        }
        // ... создание других ViewModel
        throw new IllegalArgumentException("Unknown ViewModel class");
    }
}
```

#### **1.3. Связывание View и ViewModel (LiveData)**
Во фрагменте `RecognitionFragment` происходит получение экземпляра ViewModel через фабрику и подписка на изменения данных (`observe`). Это позволяет интерфейсу автоматически обновляться при изменении данных в ViewModel, в том числе после поворота экрана.
При повороте экрана сообщение в Logcat сообщает о повторном создании активити.

**Фрагмент кода (`RecognitionFragment.java`):**
```java
// Инициализация ViewModel
ViewModelFactory factory = new ViewModelFactory(requireContext());
viewModel = new ViewModelProvider(requireActivity(), factory).get(RecognitionViewModel.class);

// Подписка на изменения
viewModel.getBirdInfo().observe(getViewLifecycleOwner(), birdInfo -> {
    if (birdInfo != null) {
        // Обновление UI: отображение названия и карточки результата
        resultBirdName.setText(birdInfo.name);
        resultCardView.setVisibility(View.VISIBLE);
    }
});

viewModel.getIsLoading().observe(getViewLifecycleOwner(), isLoading ->
        progressBar.setVisibility(isLoading ? View.VISIBLE : View.GONE));
```
---

#### **2.4. Использование MediatorLiveData**
Для объединения данных из разнородных источников (локальная база данных и удаленный API) был использован `MediatorLiveData`. Это позволило реализовать реактивный поток данных на экране деталей наблюдения: сначала пользователю мгновенно показываются данные из БД, а затем они обогащаются информацией из сети (Википедии).

В `ObservationDetailsViewModel` создана `MediatorLiveData<Observation> combinedDetails`. Она подписывается на результаты загрузки из БД и, после их получения, инициирует загрузку дополнительных данных из сети, объединяя результат в единый объект.

**Фрагмент кода (`ObservationDetailsViewModel.java`):**
```java
public class ObservationDetailsViewModel extends ViewModel {

    private final MediatorLiveData<Observation> combinedDetails = new MediatorLiveData<>();

    public void loadObservation(int observationId) {
        MutableLiveData<Observation> observationFromDb = new MutableLiveData<>();
        
        // Подписываемся на источник данных из БД
        combinedDetails.addSource(observationFromDb, observation -> {
            if (observation != null) {
                // Сразу отображаем данные из БД
                combinedDetails.setValue(observation);
                // Инициируем дозагрузку данных из сети
                fetchFreshInfo(observation);
            }
        });

        // Вызов UseCase для получения данных
        getObservationByIdUseCase.execute(observationId, new RepositoryCallback<Observation>() {
            @Override
            public void onSuccess(Observation data) {
                observationFromDb.setValue(data); // Триггерит observer выше
            }
            // ...
        });
    }
    
    // ... метод fetchFreshInfo обновляет combinedDetails новыми данными
}
```

#### **2.5. Получение данных из Базы Данных**
Получение списка наблюдений для Журнала реализовано асинхронно, чтобы не блокировать UI-поток. В архитектуре приложения это выглядит следующим образом:
1.  **ViewModel** (`JournalViewModel`) вызывает UseCase.
2.  **UseCase** (`GetJournalUseCase`) обращается к репозиторию.
3.  **Repository** (`OrnithologyRepositoryImpl`) выполняет запрос к DAO в фоновом потоке (`ExecutorService`) и маппит данные из формата БД (`ObservationData`) в доменные модели (`Observation`).

**Фрагмент кода (`OrnithologyRepositoryImpl.java`):**
```java
@Override
public void getJournal(RepositoryCallback<List<Observation>> callback) {
    // Выполнение в фоновом потоке
    executor.execute(() -> {
        try {
            // Запрос к Room DAO
            List<Observation> journal = observationDao.getAll().stream()
                    .map(mapper::mapToDomain) // Преобразование данных
                    .collect(Collectors.toList());
            // Возврат результата в главный поток
            mainThreadHandler.post(() -> callback.onSuccess(journal));
        } catch (Exception e) {
            mainThreadHandler.post(() -> callback.onFailure(e));
        }
    });
}
```

**Фрагмент кода (`JournalViewModel.java`):**
```java
public void loadJournal() {
    isLoading.setValue(true);
    getJournalUseCase.execute(new RepositoryCallback<List<Observation>>() {
        @Override
        public void onSuccess(List<Observation> data) {
            observations.setValue(data); // Обновление LiveData для RecyclerView
            isLoading.setValue(false);
        }
        // ... обработка ошибок
    });
}
```
---

### **2. Выполнение Контрольного задания**

В рамках контрольного задания приложение было приведено в соответствие с требованиями Clean Architecture с использованием MVVM:

1.  **Авторизация:** Реализована через `AuthActivity` и `RecognitionViewModel` (проверка гостевого режима, выход из аккаунта).
<img width="300" height="600" src="https://github.com/user-attachments/assets/68a6c9eb-29e3-4715-a2c7-dcfbcb013c6a"/>

2.  **Внешний сервис:** Реализовано взаимодействие с API Википедии для получения информации о птицах (использовался Retrofit, подробнее в след. работах).
3.  **Сохранение в БД:** Данные о наблюдениях сохраняются в Room Database через `SaveObservationUseCase`.

<img width="300" height="600" src="https://github.com/user-attachments/assets/509274f8-fc66-494e-994d-ea98de92ee2f"/>


5.  **Список сущностей:** Реализован экран журнала (`JournalFragment`) с `RecyclerView`, который наблюдает за списком из `JournalViewModel`.
<img width="300" height="600" src="https://github.com/user-attachments/assets/6389a20f-3670-407a-8efa-1a78868a2ac9"/>


7.  **Детальная страница:** Реализован `ObservationDetailFragment`, получающий данные через `ObservationDetailsViewModel`.
<img width="300" height="600" src="https://github.com/user-attachments/assets/f900cdc2-550a-4e97-a01e-a0110822375c"/>


9.  **Гостевой режим:** В `RecognitionViewModel` добавлена логика `isGuest()`, скрывающая кнопку "Сохранить" и блокирующая доступ к журналу.
<img width="300" height="600" src="https://github.com/user-attachments/assets/f9e14ee8-c5df-43db-ab90-3d5b059deb49"/>


11.  **Обученная модель:** В `OrnithologyRepositoryImpl` подготовлен метод `recognizeBird` для интеграции TFLite.

#### **Скриншоты работы приложения:**

<img width="300" height="600" src="https://github.com/user-attachments/assets/afa0338d-30a8-4bd3-a50d-c751023d9b74"/>



