### **1. Выполнение заданий**

#### **1.1. Создание ViewModel**
Для отделения логики отображения от `Activity`/`Fragment` и сохранения данных при повороте экрана были созданы классы ViewModel.
В качестве основного примера реализована `RecognitionViewModel`, которая управляет процессом распознавания птиц и хранит состояние экрана (загрузка, результат, ошибка).

**Фрагмент кода (`RecognitionViewModel.java`):**
```java
public class RecognitionViewModel extends ViewModel {

    // UseCases для взаимодействия с Domain слоем
    private final RecognizeBirdUseCase recognizeBirdUseCase;
    private final GetBirdInfoUseCase getBirdInfoUseCase;
    // ... другие UseCases

    // LiveData для хранения состояния UI
    private final MutableLiveData<String> recognitionResult = new MutableLiveData<>();
    private final MutableLiveData<BirdInfo> birdInfo = new MutableLiveData<>();
    private final MutableLiveData<Boolean> isLoading = new MutableLiveData<>();

    public RecognitionViewModel(RecognizeBirdUseCase recognizeBirdUseCase, ...) {
        this.recognizeBirdUseCase = recognizeBirdUseCase;
        // ... инициализация
    }

    // Геттеры для LiveData, чтобы View могла подписаться (возвращаем неизменяемую LiveData)
    public LiveData<BirdInfo> getBirdInfo() { return birdInfo; }
    public LiveData<Boolean> getIsLoading() { return isLoading; }

    // Метод логики
    public void startRecognition(byte[] imageBytes) {
        isLoading.setValue(true); // Обновление состояния
        recognizeBirdUseCase.execute(imageBytes, new RepositoryCallback<String>() {
            @Override
            public void onSuccess(String birdName) {
                fetchBirdInfo(birdName); // Цепочка вызовов
            }
            @Override
            public void onFailure(Exception e) {
                isLoading.setValue(false);
                // Обработка ошибки
            }
        });
    }
}
```

#### **1.2. Реализация ViewModelFactory**
Так как наши ViewModel требуют зависимостей (UseCases, которые в свою очередь требуют Repository), была реализована фабрика `ViewModelFactory`. Это позволяет внедрять зависимости при создании ViewModel.

**Фрагмент кода (`ViewModelFactory.java`):**
```java
public class ViewModelFactory implements ViewModelProvider.Factory {

    private final OrnithologyRepository ornithologyRepository;
    private final AuthRepository authRepository;

    public ViewModelFactory(Context context) {
        // Инициализация репозиториев (Data Layer)
        AppDatabase db = AppDatabase.getDatabase(context.getApplicationContext());
        this.ornithologyRepository = new OrnithologyRepositoryImpl(db.observationDao());
        UserPrefsStorage userPrefs = new UserPrefsStorage(context);
        this.authRepository = new AuthRepositoryImpl(userPrefs);
    }

    @NonNull
    @Override
    public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
        if (modelClass.isAssignableFrom(RecognitionViewModel.class)) {
            // Внедрение UseCases (Domain Layer) во ViewModel
            return (T) new RecognitionViewModel(
                    new RecognizeBirdUseCase(ornithologyRepository),
                    new GetBirdInfoUseCase(ornithologyRepository),
                    // ... другие зависимости
            );
        }
        // ... создание других ViewModel
        throw new IllegalArgumentException("Unknown ViewModel class");
    }
}
```

#### **1.3. Связывание View и ViewModel (LiveData)**
Во фрагменте `RecognitionFragment` происходит получение экземпляра ViewModel через фабрику и подписка на изменения данных (`observe`). Это позволяет интерфейсу автоматически обновляться при изменении данных в ViewModel, в том числе после поворота экрана.
При повороте экрана сообщение в Logcat сообщает о повторном создании активити.

**Фрагмент кода (`RecognitionFragment.java`):**
```java
// Инициализация ViewModel
ViewModelFactory factory = new ViewModelFactory(requireContext());
viewModel = new ViewModelProvider(requireActivity(), factory).get(RecognitionViewModel.class);

// Подписка на изменения
viewModel.getBirdInfo().observe(getViewLifecycleOwner(), birdInfo -> {
    if (birdInfo != null) {
        // Обновление UI: отображение названия и карточки результата
        resultBirdName.setText(birdInfo.name);
        resultCardView.setVisibility(View.VISIBLE);
    }
});

viewModel.getIsLoading().observe(getViewLifecycleOwner(), isLoading ->
        progressBar.setVisibility(isLoading ? View.VISIBLE : View.GONE));
```

---

### **2. Выполнение Контрольного задания**

В рамках контрольного задания приложение было приведено в соответствие с требованиями Clean Architecture с использованием MVVM:

1.  **Авторизация:** Реализована через `AuthActivity` и `RecognitionViewModel` (проверка гостевого режима, выход из аккаунта).
<img width="300" height="600" src="https://github.com/user-attachments/assets/68a6c9eb-29e3-4715-a2c7-dcfbcb013c6a"/>

2.  **Внешний сервис:** Реализовано взаимодействие с API Википедии для получения информации о птицах (использовался Retrofit, подробнее в след. работах).
3.  **Сохранение в БД:** Данные о наблюдениях сохраняются в Room Database через `SaveObservationUseCase`.

<img width="300" height="600" src="https://github.com/user-attachments/assets/509274f8-fc66-494e-994d-ea98de92ee2f"/>


5.  **Список сущностей:** Реализован экран журнала (`JournalFragment`) с `RecyclerView`, который наблюдает за списком из `JournalViewModel`.
<img width="300" height="600" src="https://github.com/user-attachments/assets/6389a20f-3670-407a-8efa-1a78868a2ac9"/>


7.  **Детальная страница:** Реализован `ObservationDetailFragment`, получающий данные через `ObservationDetailsViewModel`.
<img width="300" height="600" src="https://github.com/user-attachments/assets/f900cdc2-550a-4e97-a01e-a0110822375c"/>


9.  **Гостевой режим:** В `RecognitionViewModel` добавлена логика `isGuest()`, скрывающая кнопку "Сохранить" и блокирующая доступ к журналу.
<img width="300" height="600" src="https://github.com/user-attachments/assets/f9e14ee8-c5df-43db-ab90-3d5b059deb49"/>


11.  **Обученная модель:** В `OrnithologyRepositoryImpl` подготовлен метод `recognizeBird` для интеграции TFLite.

#### **Скриншоты работы приложения:**

<img width="300" height="600" src="https://github.com/user-attachments/assets/afa0338d-30a8-4bd3-a50d-c751023d9b74"/>



